diff -up mplayer-export-2010-04-24/configure.x264 mplayer-export-2010-04-24/configure
--- mplayer-export-2010-04-24/configure.x264	2010-04-24 19:00:26.000000000 +0200
+++ mplayer-export-2010-04-24/configure	2010-04-24 19:00:26.000000000 +0200
@@ -7482,7 +7482,7 @@ if test "$_x264" = auto ; then
   cat > $TMPC << EOF
 #include <inttypes.h>
 #include <x264.h>
-#if X264_BUILD < 89
+#if X264_BUILD < 65
 #error We do not support old versions of x264. Get the latest from git.
 #endif
 int main(void) { x264_encoder_open((void*)0); return 0; }
diff -up mplayer-export-2010-04-24/libmpcodecs/ve_x264.c.x264 mplayer-export-2010-04-24/libmpcodecs/ve_x264.c
--- mplayer-export-2010-04-24/libmpcodecs/ve_x264.c.x264	2010-04-20 11:14:54.000000000 +0200
+++ mplayer-export-2010-04-24/libmpcodecs/ve_x264.c	2010-04-24 19:18:51.000000000 +0200
@@ -60,6 +60,20 @@ static int turbo = 0;
 static x264_param_t param;
 static int parse_error = 0;
 
+static int encode_nals(uint8_t *buf, int size, x264_nal_t *nals, int nnal){
+    uint8_t *p = buf;
+    int i;
+
+    for(i = 0; i < nnal; i++){
+        int s = x264_nal_encode(p, &size, 1, nals + i);
+        if(s < 0)
+            return -1;
+        p += s;
+    }
+
+    return p - buf;
+}
+
 static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts);
 static int encode_frame(struct vf_instance *vf, x264_picture_t *pic_in);
 
@@ -152,7 +166,6 @@ static int config(struct vf_instance *vf
     param.i_height = height;
     param.i_fps_num = mod->mux->h.dwRate;
     param.i_fps_den = mod->mux->h.dwScale;
-    param.b_vfr_input = 0;
     param.vui.i_sar_width = d_width*height;
     param.vui.i_sar_height = d_height*width;
 
@@ -177,17 +190,25 @@ static int config(struct vf_instance *vf
     }
 
     if(!param.b_repeat_headers){
+        uint8_t *extradata;
         x264_nal_t *nal;
-        int extradata_size, nnal;
+        int extradata_size, nnal, i, s = 0;
 
-        extradata_size = x264_encoder_headers(mod->x264, &nal, &nnal);
+        x264_encoder_headers(mod->x264, &nal, &nnal);
+
+        /* 5 bytes NAL header + worst case escaping */
+        for(i = 0; i < nnal; i++)
+            s += 5 + nal[i].i_payload * 4 / 3;
+
+        extradata = malloc(s);
+        extradata_size = encode_nals(extradata, s, nal, nnal);
 
         mod->mux->bih= realloc(mod->mux->bih, sizeof(BITMAPINFOHEADER) + extradata_size);
-        memcpy(mod->mux->bih + 1, nal->p_payload, extradata_size);
+        memcpy(mod->mux->bih + 1, extradata, extradata_size);
         mod->mux->bih->biSize= sizeof(BITMAPINFOHEADER) + extradata_size;
     }
 
-    if (param.i_bframe > 1 && param.i_bframe_pyramid)
+    if (param.i_bframe > 1 && param.b_bframe_pyramid)
         mod->mux->decoder_delay = 2;
     else
         mod->mux->decoder_delay = param.i_bframe ? 1 : 0;
@@ -198,10 +219,12 @@ static int config(struct vf_instance *vf
 static int control(struct vf_instance *vf, int request, void *data)
 {
     h264_module_t *mod=(h264_module_t*)vf->priv;
+    int count = 256; // giant HACK, x264_encoder_encode may incorrectly return 0
+                     // when threads > 1 and delayed frames pending
     switch(request){
         case VFCTRL_FLUSH_FRAMES:
-            while (x264_encoder_delayed_frames(mod->x264) > 0)
-                encode_frame(vf, NULL);
+            while(encode_frame(vf, NULL) == 0 && --count);
+                while(encode_frame(vf, NULL) > 0);
             return CONTROL_TRUE;
         default:
             return CONTROL_UNKNOWN;
@@ -251,17 +274,23 @@ static int encode_frame(struct vf_instan
     x264_picture_t pic_out;
     x264_nal_t *nal;
     int i_nal;
-    int i_size;
-
-    i_size = x264_encoder_encode(mod->x264, &nal, &i_nal, pic_in, &pic_out);
+    int i_size = 0;
+    int i;
 
-    if(i_size<0) {
+    if(x264_encoder_encode(mod->x264, &nal, &i_nal, pic_in, &pic_out) < 0) {
         mp_msg(MSGT_MENCODER, MSGL_ERR, "x264_encoder_encode failed\n");
         return -1;
     }
+
+    for(i=0; i < i_nal; i++) {
+        int i_data = mod->mux->buffer_size - i_size;
+        i_size += x264_nal_encode(mod->mux->buffer + i_size, &i_data, 1, &nal[i]);
+    }
     if(i_size>0) {
-        int keyframe = pic_out.b_keyframe;
-        memcpy(mod->mux->buffer, nal->p_payload, i_size);
+        int keyframe = (pic_out.i_type == X264_TYPE_IDR) ||
+                       (pic_out.i_type == X264_TYPE_I
+                        && param.i_frame_reference == 1
+                        && !param.i_bframe);
         muxer_write_chunk(mod->mux, i_size, keyframe?AVIIF_KEYFRAME:0, MP_NOPTS_VALUE, MP_NOPTS_VALUE);
     }
     else
